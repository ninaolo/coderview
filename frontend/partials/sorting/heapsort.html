<div class="row">

    <div class="col-lg-6 col-lg-offset-3 centering">
        <h1>HeapSort</h1>
        <br>
        <h3>What</h3>
        <p>Sorts by using a <span class="b">heap</span>. The input array can be used as the actual heap -->
            <span class="b">no additional storage</span>.</p>

        <h3>How</h3>
        <ul class="list-group">
            <li class="list-group-item">STEP 1: Turn array into max-heap --> <span class="b">O(N)</span></li>
            <li class="list-group-item">STEP 2: Swap root N times with last element & make sure new root comes to right place
                --> <span class="b">O(N log N)</span></li>
        </ul>

        <h3>Complexity</h3>
        <p>Time average/best/worst: O(N + N log N) = <span class="b">O(N log N)</span> <br>
            <br>
            Space: <span class="b">O(1)</span>
        </p>

    </div>

</div>

<div class="row">

    <h3>Implementation</h3>

    <pre>
        <code ng-prism class="language-java">

            public class Coderview {

                public static void heapSort(Comparable[] array) {
                    int n = array.length;

                    // STEP 1: Build heap bottom-up (begin at lowest level with children) --> O(N).
                    for (int i = n / 2 - 1; i >= 0; i--) {
                        heapify(array, i, n);
                    }

                    // STEP 2: swap max root with last child, heapify on the smaller heap --> O(N log N).
                    for (int iLast = n - 1; iLast >= 0; iLast--) {
                        swap(0, iLast, array);
                        heapify(array, 0, iLast);
                    }
                }

                private static void heapify(Comparable[] array, int iSubRoot, int heapSize) {
                    int iLeft = iSubRoot * 2 + 1;
                    int iRight = iSubRoot * 2 + 2;
                    int iLargest = iSubRoot;

                    if (iLeft < heapSize && array[iLeft].compareTo(array[iLargest]) > 0) {
                        iLargest = iLeft;
                    }

                    if (iRight < heapSize && array[iRight].compareTo(array[iLargest]) > 0) {
                        iLargest = iRight;
                    }

                    if (iLargest != iSubRoot) {
                        swap(iLargest, iSubRoot, array);

                        // Recursively heapify the new subtree.
                        heapify(array, iLargest, heapSize);
                    }
                }

                private static void swap(int iFirst, int iSecond, Comparable[] array) {
                    Comparable tmp = array[iFirst];
                    array[iFirst] = array[iSecond];
                    array[iSecond] = tmp;
                }
            }

        </code>
    </pre>

</div>


