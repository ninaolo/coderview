<div class="row">

    <div class="col-lg-6 col-lg-offset-3 centering">
        <h1>MergeSort</h1>
        <br>
        <h3>What</h3>
        <p><span class="b">Divide-and-conquer</span> algorithm that sorts by repeatedly dividing the list in two
            and then <span class="b">merging</span> the two sub-lists. Usually implemented with array copies and
        therefore takes up some <span class="b">extra space</span>.</p>

        <h3>How</h3>
        <ul class="list-group">
            <li class="list-group-item">Split list in two</li>
            <li class="list-group-item">Recursively sort left part</li>
            <li class="list-group-item">Recursively sort right part</li>
            <li class="list-group-item">Merge</li>
        </ul>

        <h3>Complexity</h3>
        <p>Average/best/worst time: <span class="b">O(N log N)</span></p>
        <p>Space: <span class="b">O(N)</span> for extra storage</p>

    </div>

</div>

<div class="row">

    <h3>Implementation</h3>
    <pre>
        <code ng-prism class="language-java">

            public class Coderview {

                private static void merge(Comparable[] left, Comparable[] right, Comparable[] list) {

                    // Define the indexes.
                    int iLeft = 0;
                    int iRight = 0;
                    int iList = 0;

                    // Loop and copy the smallest element each time from left/right list.
                    while (iLeft < left.length && iRight < right.length) {
                        if (left[iLeft].compareTo(right[iRight]) < 0) {
                            list[iList] = left[iLeft];
                            iLeft++;
                        } else {
                            list[iList] = right[iRight];
                            iRight++;
                        }
                        iList++;
                    }

                    // Copy elements that are left.
                    System.arraycopy(left, iLeft, list, iList, left.length - iLeft);
                    System.arraycopy(right, iRight, list, iList, right.length - iRight);
                }

                public static void mergeSort(Comparable[] list) {

                    // Base case - otherwise infinite recursion.
                    if (list.length == 1) {
                        return;
                    }

                    // Split in two, creating two new lists in memory and copying the elements.
                    Comparable[] left = new Comparable[list.length / 2];
                    Comparable[] right = new Comparable[list.length - left.length];
                    System.arraycopy(list, 0, left, 0, left.length);
                    System.arraycopy(list, left.length, right, 0, right.length);

                    // Recursively sort both halves.
                    mergeSort(left);
                    mergeSort(right);

                    // Merge the two sorted parts.
                    merge(left, right, list);
                }
            }

        </code>
    </pre>

</div>


